/*
 * $Id$
 *
 * File is automatically generated by the Xtext language generator.
 * Do not change it.
 *
 * SARL is an general-purpose agent programming language.
 * More details on http://www.sarl.io
 *
 * Copyright 2014-2016 the original authors and authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.sarl.lang.documentation;

import io.sarl.lang.services.SARLGrammarAccess;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;
import javax.inject.Inject;
import org.eclipse.xtext.AbstractElement;
import org.eclipse.xtext.AbstractRule;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.UntilToken;
import org.eclipse.xtext.formatting2.ITextReplacerContext;
import org.eclipse.xtext.formatting2.regionaccess.IComment;
import org.eclipse.xtext.formatting2.regionaccess.ILineRegion;
import org.eclipse.xtext.formatting2.regionaccess.ITextRegionAccess;
import org.eclipse.xtext.formatting2.regionaccess.ITextSegment;
import org.eclipse.xtext.util.Strings;
import org.eclipse.xtext.xbase.compiler.IAppendable;
import org.eclipse.xtext.xbase.compiler.StringBuilderBasedAppendable;
import org.eclipse.xtext.xbase.lib.Pure;

/** Formatter a documentation string.
 */
public class DocumentationFormatter implements IDocumentationFormatter {

	private String mlLinePrefix;

	private String mlStart;

	private String mlEnd;

	private String slPrefix;

	@Pure
	public String getMultilineCommentStartSymbols() {
		return this.mlStart;
	}

	/** Change the characters that must be used to start a comment.
	 * @param symbol the start comment symbols.
	 */
	public void setMultilineCommentStartSymbols(String symbols) {
		this.mlStart = symbols;
	}

	@Pure
	public String getMultilineCommentEndSymbols() {
		return this.mlEnd;
	}

	/** Change the characters that must be used to end a comment.
	 * @param symbol the end comment symbols.
	 */
	public void setMultilineCommentEndSymbols(String symbols) {
		this.mlEnd = symbols;
	}

	@Pure
	public String getMultilineCommentLinePrefix() {
		return this.mlLinePrefix;
	}

	/** Change the line prefix for the multiline comments.
	 * @param prefix the new prefix.
	 */
	public void setMultilineCommentLinePrefix(String prefix) {
		this.mlLinePrefix = prefix;
	}

	@Pure
	public String getSinglelineCommentPrefix() {
		return this.slPrefix;
	}

	/** Change the line prefix for the singleline comments.
	 * @param prefix the new prefix.
	 */
	public void setSinglelineCommentPrefix(String prefix) {
		this.slPrefix = prefix;
	}

	@Inject
	public void setGrammarAccess(SARLGrammarAccess access) {
		if (this.mlStart == null || this.mlEnd == null) {
			AbstractRule mlRule = access.getML_COMMENTRule();
			for (AbstractElement element : ((Group) mlRule.getAlternatives()).getElements()) {
				if (element instanceof Keyword && this.mlStart == null) {
					this.mlStart = ((Keyword) element).getValue();
				} else if (element instanceof UntilToken && this.mlEnd == null) {
					this.mlEnd = ((Keyword) ((UntilToken) element).getTerminal()).getValue();
				}
			}
		}
		if (this.mlLinePrefix == null) {
			this.mlLinePrefix = this.mlStart.substring(this.mlStart.length() - 1);
		}
		if (this.slPrefix == null) {
			AbstractRule slRule = access.getSL_COMMENTRule();
			for (AbstractElement element : ((Group) slRule.getAlternatives()).getElements()) {
				if (element instanceof Keyword) {
					this.slPrefix = ((Keyword) element).getValue().trim();
					break;
				}
			}
		}
	}

	@Pure
	public String formatMultilineComment(String doc) {
		return formatMultilineComment(doc, (String) null);
	}

	@Pure
	public String formatMultilineComment(String doc, String indentation) {
		IAppendable appendable = new StringBuilderBasedAppendable();
		formatMultilineComment(doc, indentation, appendable);
		return appendable.getContent();
	}

	@Pure
	public void formatMultilineComment(String doc, IAppendable appendable) {
		formatMultilineComment(doc, null, appendable);
	}

	@Pure
	public void formatMultilineComment(String doc, String indentation, IAppendable appendable) {
		if (!Strings.isEmpty(doc)) {
			final Map<Integer, List<Replacement>> replacements = new TreeMap();
			formatMultlineComment(
					indentation,
					Strings.newLine(),
					new AppendableBackend(doc, replacements, 0, doc.length()));
			applyReplacements(appendable, doc, replacements);
		}
	}

	private void applyReplacements(IAppendable appendable, String documentation, Map<Integer, List<Replacement>> replacements) {
		int offset = 0;
		for (List<Replacement> replacementList : replacements.values()) {
			for (Replacement replacement : replacementList) {
				if (replacement.getOffset() < offset) {
					throw new IllegalStateException("replacements are overlapping");
				}
				if (replacement.getOffset() > offset) {
					String notReplacedString = documentation.substring(offset, replacement.getOffset());
					appendable.append(notReplacedString);
					offset = replacement.getOffset();
				}
				appendable.append(replacement.getText());
				offset += replacement.getLength();
			}
		}
		if (offset < documentation.length()) {
			String notReplacedString = documentation.substring(offset);
			appendable.append(notReplacedString);
		}
	}

	/** Replies the string that should appear at the start of each documentation line.
	 * @param prefix the default prefix text.
	 * @param isFirstLine indicates if the prefix string is for the first line of the documentation,
	 *    or the other lines.
	 * @param isLastLine indicates if the prefix string is for the last line of the documentation,
	 *    or the other lines.
	 * @return the real prefix text.
	 */
	@Pure
	protected String getLinePrefix(String prefix, boolean isFirstLine, boolean isLastLine) {
		if (isFirstLine) {
			return " ";
		} else if (isLastLine) {
			return " " + prefix;
		}
		return " " + prefix + " ";
	}

	/** Replies the string that should appear at the end of each documentation line.
	 * @param postfix the default postfix text.
	 * @return the real postfix text.
	 */
	@Pure
	protected String getLinePostfix(String postfix) {
		return postfix;
	}

	/** Format a line of comment.
	 * @param appendable the result of the format.
	 * @param line the line to format.
	 * @param prefix the expected prefix text for the line.
	 * @param postfix the expected postfix text for the line.
	 */
	@Pure
	protected void formatLine(IAppendable appendable, String line, String prefix, String postfix) {
		String simpleLine = (line == null) ? "" : line.trim();
		String simplePrefix = (prefix == null) ? "" : prefix.trim();
		String simplePostfix = (postfix == null) ? "" : postfix.trim();
		if (prefix != null) {
			appendable.append(prefix);
		}
		if (!Strings.isEmpty(simplePrefix) && simpleLine.startsWith(simplePrefix)) {
			int index = simplePrefix.length();
			while (index < simpleLine.length() && Character.isSpaceChar(simpleLine.charAt(index))) {
				++index;
			}
			simpleLine = simpleLine.substring(index);
		}
		if (!Strings.isEmpty(simplePostfix) && simpleLine.endsWith(simplePostfix)) {
			int index = simpleLine.length() - simplePostfix.length() - 1;
			while (index < simpleLine.length() && Character.isSpaceChar(simpleLine.charAt(index))) {
				--index;
			}
			simpleLine = simpleLine.substring(0, index + 1);
		}
		appendable.append(simpleLine);
		if (postfix != null) {
			appendable.append(postfix);
		}
	}

	@Pure
	public void formatMultilineComment(ITextReplacerContext context, IComment comment) {
		formatMultlineComment(
				context.getIndentationString(),
				context.getNewLinesString(1),
				new RegionBackend(context, comment));
	}

	@Pure
	public String formatSinglelineComment(String doc) {
		return formatSinglelineComment(doc, (String) null);
	}

	@Pure
	public String formatSinglelineComment(String doc, String indentation) {
		StringBuilderBasedAppendable appendable = new StringBuilderBasedAppendable();
		formatSinglelineComment(doc, indentation, appendable);
		return appendable.getContent();
	}

	@Pure
	public void formatSinglelineComment(String doc, IAppendable appendable) {
		formatSinglelineComment(doc, null, appendable);
	}

	@Pure
	public void formatSinglelineComment(String doc, String indentation, IAppendable appendable) {
		if (!Strings.isEmpty(doc)) {
			final Map<Integer, List<Replacement>> replacements = new TreeMap();
			formatSinglelineComment(
					indentation,
					new AppendableBackend(doc, replacements,
						Math.max(0, doc.indexOf(getSinglelineCommentPrefix())),
						doc.length()));
			applyReplacements(appendable, doc, replacements);
		}
	}

	public void formatSinglelineComment(ITextReplacerContext context, IComment comment) {
		formatSinglelineComment(
				context.getIndentationString(),
				new RegionBackend(context, comment));
	}

	private <T> void formatSinglelineComment(
			String indentationString,
			FormatterBackend<T> backend) {
		String indent = Strings.emptyIfNull(indentationString);
		String prefix = getSinglelineCommentPrefix();
		T currentLine = backend.getFirstLine(backend.getCommentOffset());
		boolean firstLine = true;
		while (currentLine != null) {
			int lineOffset = backend.getLineOffset(currentLine);
			if (lineOffset >= backend.getCommentEndOffset()) {
				// Ok, break is not the best statement, but it makes the code easier to read.
				break;
			}
			String lineText = backend.getLineText(currentLine);
			currentLine = backend.getNextLine(currentLine);
			int symbolOffset = lineText.indexOf(prefix);
			int textZoneOffset;
			if (symbolOffset >= 0) {
				if (firstLine) {
					firstLine = false;
				} else {
					backend.replace(symbolOffset + lineOffset, 0, indent);
				}
				textZoneOffset = symbolOffset + prefix.length();
			} else {
				if (firstLine) {
					firstLine = false;
					backend.replace(lineOffset, 0, prefix);
				} else {
					backend.replace(lineOffset, 0, indent + prefix);
				}
				textZoneOffset = 0;
			}
			int textOffset = textZoneOffset;
			while (textOffset < lineText.length() && isSpaceChar(lineText.charAt(textOffset))) {
				++textOffset;
			}
			if ((textOffset >= lineText.length()) || Character.isWhitespace(lineText.charAt(textOffset))) {
				// No text in the comment.
				if (textOffset != textZoneOffset) {
					// Remove trailing spaces
					backend.replace(lineOffset + textZoneOffset, textOffset - textZoneOffset, "");
				}
			} else {
				// Text in comment.
				if ((textZoneOffset + 1) != textOffset) {
					// Fixing the invalid number of spaces after the start symbols.
					backend.replace(lineOffset + textZoneOffset, textOffset - textZoneOffset, " ");
				}
				// Remove trailing white spaces.
				int endTextOffset = lineText.length() - 1;
				while (endTextOffset > textOffset && isSpaceChar(lineText.charAt(endTextOffset))) {
					--endTextOffset;
				}
				++endTextOffset;
				if (endTextOffset != lineText.length()) {
					backend.replace(lineOffset + endTextOffset, lineText.length() - endTextOffset, "");
				}
			}
		}
	}

	private static boolean isSpaceChar(char character) {
		return (((1 << Character.SPACE_SEPARATOR) >> Character.getType((int) character)) & 1) != 0;
	}

	private <T> void formatMultlineComment(
			String indentationString, String newLineString,
			FormatterBackend<T> backend) {
		final String indent = Strings.emptyIfNull(indentationString);
		final String postfix = getLinePostfix(null);
		final String startSymbols = getMultilineCommentStartSymbols();
		final String fullText = backend.getCommentText();
		final int commentOffset = backend.getCommentOffset();
		final int endCommentOffset = backend.getCommentEndOffset();
		int startOffset = fullText.indexOf(startSymbols);
		if (startOffset < 0) {
			backend.replace(0, 0, startSymbols);
			startOffset = 0;
		} else {
			startOffset += startSymbols.length();
		}
		final String endSymbols = getMultilineCommentEndSymbols();
		int endOffset = fullText.indexOf(endSymbols, startOffset);
		if (endOffset < 0) {
			endOffset = fullText.length();
		}
		final String startLineSymbols = getMultilineCommentLinePrefix();
		T currentLine = backend.getFirstLine(startOffset + commentOffset);
		boolean firstLine = true;
		while (currentLine != null) {
			int lineOffset = backend.getLineOffset(currentLine);
			if (lineOffset >= endCommentOffset) {
				// Ok, break is not the best statement, but it makes the code easier to read.
				break;
			}
			int textStartOffset;
			String referenceText = fullText.substring(
					Math.max(lineOffset - commentOffset, startOffset),
					Math.min(backend.getLineEndOffset(currentLine) - commentOffset, endOffset));
			// Move to next line
			currentLine = backend.getNextLine(currentLine);
			if (!Strings.isEmpty(referenceText) || currentLine != null) {
				String prefix;
				if (firstLine) {
					firstLine = false;
					textStartOffset = 0;
					// Skip prefix symbols (for Javadoc-like comments).
					while ((textStartOffset < referenceText.length())
								&& referenceText.regionMatches(textStartOffset, startLineSymbols, 0, startLineSymbols.length())) {
						textStartOffset += startLineSymbols.length();
					}
					referenceText = referenceText.substring(textStartOffset);
					prefix = getLinePrefix(null, true, false);
					textStartOffset += Math.max(lineOffset - commentOffset, startOffset);
				} else {
					textStartOffset = Math.max(lineOffset - commentOffset, startOffset);
					prefix = indent + getLinePrefix(startLineSymbols, false, false);
				}
				// Format the line
				StringBuilderBasedAppendable appendable = new StringBuilderBasedAppendable();
				formatLine(appendable, referenceText, prefix, postfix);
				String newText = appendable.getContent();
				// Change the text
				if (!Strings.equal(referenceText, newText)) {
					backend.replace(
							textStartOffset + commentOffset,
							referenceText.length(),
							newText);
				}
			}
		}
		// Format the closing symbols.
		int textEndOffset = endOffset - 1;
		while (textEndOffset > startOffset
				&& isSpaceChar(fullText.charAt(textEndOffset))) {
			--textEndOffset;
		}
		String referenceText;
		StringBuilderBasedAppendable appendable = new StringBuilderBasedAppendable();
		if (textEndOffset <= startOffset || !Character.isWhitespace(fullText.charAt(textEndOffset))) {
			// Do not find a new line.
			appendable.append(newLineString);
			textEndOffset = endOffset;
			referenceText = endSymbols;
		} else {
			++textEndOffset;
			referenceText = fullText.substring(textEndOffset, endOffset) + endSymbols;
		}
		String prefix = indent + getLinePrefix(endSymbols, false, true);
		formatLine(appendable, "", prefix, null);
		String newText = appendable.getContent();
		if (!Strings.equal(referenceText, newText)) {
			backend.replace(
					textEndOffset + commentOffset,
					referenceText.length(),
					newText);
		}
	}

	private interface FormatterBackend<T> {
		T getFirstLine(int offset);
		T getNextLine(T currentLine);
		int getLineOffset(T currentLine);
		int getLineEndOffset(T currentLine);
		void replace(int offset, int length, String newText);
		String getCommentText();
		String getLineText(T line);
		int getCommentOffset();
		int getCommentEndOffset();
	}

	private static class Line {
		private final int startOffset;
		private final int endOffset;
		public Line(String text, int offset) {
			// Search for the begining of the line.
			int soffset = offset;
			while (soffset >= 0 && !isNewLine(text.charAt(soffset))) {
				--soffset;
			}
			this.startOffset = soffset + 1;
			// Search for the end of the line.
			int eoffset = offset;
			while (eoffset < text.length() && !isNewLine(text.charAt(eoffset))) {
				++eoffset;
			}
			this.endOffset = eoffset;
		}
		public int getStartOffset() {
			return this.startOffset;
		}
		public int getEndOffset() {
			return this.endOffset;
		}
		private static boolean isNewLine(char character) {
			if (character == '\n' || character == '\r' || character == '\f') {
				return true;
			}
			return ((((1 << Character.LINE_SEPARATOR)
					| (1 << Character.PARAGRAPH_SEPARATOR)) >> Character.getType((int) character)) & 1) != 0;
		}
	}

	private static class Replacement {
		private final int offset;
		private final int length;
		private final String text;
		public Replacement(int offset, int length, String text) {
			this.offset = offset;
			this.length = length;
			this.text = text;
		}
		public int getOffset() {
			return this.offset;
		}
		public int getLength() {
			return this.length;
		}
		public String getText() {
			return this.text;
		}
	}

	private static class RegionBackend implements FormatterBackend<ILineRegion> {

		private final ITextReplacerContext context;

		private final ITextRegionAccess access;

		private final IComment comment;

		public RegionBackend(ITextReplacerContext context, IComment comment) {
			this.context = context;
			this.comment = comment;
			this.access = comment.getTextRegionAccess();
		}

		public String getCommentText() {
			return this.comment.getText();
		}

		public String getLineText(ILineRegion line) {
			ITextSegment segment = this.access.regionForOffset(line.getOffset(), line.getLength());
			return segment.getText();
		}

		public int getCommentOffset() {
			return this.comment.getOffset();
		}

		public int getCommentEndOffset() {
			return this.comment.getEndOffset();
		}

		public ILineRegion getFirstLine(int offset) {
			return this.access.regionForLineAtOffset(offset);
		}

		public ILineRegion getNextLine(ILineRegion currentLine) {
			return currentLine.getNextLine();
		}

		public int getLineOffset(ILineRegion currentLine) {
			return currentLine.getOffset();
		}

		public int getLineEndOffset(ILineRegion currentLine) {
			return currentLine.getEndOffset();
		}

		public void replace(int offset, int length, String newText) {
			ITextSegment target = this.access.regionForOffset(offset, length);
			this.context.addReplacement(target.replaceWith(newText));
		}

	}

	private static class AppendableBackend implements FormatterBackend<Line> {

		private final String documentation;

		private final Map<Integer, List<Replacement>> replacements;

		private final int commentOffset;

		private final int commentEndOffset;

		public AppendableBackend(String documentation, Map<Integer, List<Replacement>> replacements,
				int commentOffset, int commentEndOffset) {
			this.documentation = documentation;
			this.replacements = replacements;
			this.commentOffset = commentOffset;
			this.commentEndOffset = commentEndOffset;
		}

		public String getCommentText() {
			return this.documentation;
		}

		public String getLineText(Line line) {
			return this.documentation.substring(line.getStartOffset(), line.getEndOffset());
		}

		public int getCommentOffset() {
			return this.commentOffset;
		}

		public int getCommentEndOffset() {
			return this.commentEndOffset;
		}

		public Line getFirstLine(int offset) {
			return new Line(this.documentation, offset);
		}

		public Line getNextLine(Line currentLine) {
			try {
				return new Line(this.documentation, currentLine.getEndOffset() + 1);
			} catch (Throwable exception) {
				return null;
			}
		}

		public int getLineOffset(Line currentLine) {
			return currentLine.getStartOffset();
		}

		public int getLineEndOffset(Line currentLine) {
			return currentLine.getEndOffset();
		}

		public void replace(int offset, int length, String newText) {
			List<Replacement> list = this.replacements.get(offset);
			if (list == null) {
				list = new ArrayList<>();
				this.replacements.put(offset, list);
			}
			list.add(new Replacement(offset, length, newText));
		}

	}

}

