/*
 * $Id$
 *
 * File is automatically generated by the Xtext language generator.
 * Do not change it.
 *
 * SARL is an general-purpose agent programming language.
 * More details on http://www.sarl.io
 *
 * Copyright 2014-2016 the original authors and authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.sarl.lang.documentation;

import io.sarl.lang.services.SARLGrammarAccess;
import javax.inject.Inject;
import org.eclipse.xtext.AbstractElement;
import org.eclipse.xtext.AbstractRule;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.UntilToken;
import org.eclipse.xtext.formatting2.ITextReplacerContext;
import org.eclipse.xtext.formatting2.regionaccess.IComment;
import org.eclipse.xtext.formatting2.regionaccess.ILineRegion;
import org.eclipse.xtext.formatting2.regionaccess.ITextRegionAccess;
import org.eclipse.xtext.formatting2.regionaccess.ITextSegment;
import org.eclipse.xtext.util.Strings;
import org.eclipse.xtext.xbase.compiler.IAppendable;
import org.eclipse.xtext.xbase.compiler.StringBuilderBasedAppendable;
import org.eclipse.xtext.xbase.lib.Pure;

/** Formatter a documentation string.
 */
public class DocumentationFormatter implements IDocumentationFormatter {

	private String mlLinePrefix;

	private String mlStart;

	private String mlEnd;

	private String slPrefix;

	@Pure
	public String getMultilineCommentStartSymbols() {
		return this.mlStart;
	}

	/** Change the characters that must be used to start a comment.
	 * @param symbol the start comment symbols.
	 */
	public void setMultilineCommentStartSymbols(String symbols) {
		this.mlStart = symbols;
	}

	@Pure
	public String getMultilineCommentEndSymbols() {
		return this.mlEnd;
	}

	/** Change the characters that must be used to end a comment.
	 * @param symbol the end comment symbols.
	 */
	public void setMultilineCommentEndSymbols(String symbols) {
		this.mlEnd= symbols;
	}

	@Pure
	public String getMultilineCommentLinePrefix() {
		return this.mlLinePrefix;
	}

	/** Change the line prefix for the multiline comments.
	 * @param prefix the new prefix.
	 */
	public void setMultilineCommentLinePrefix(String prefix) {
		this.mlLinePrefix = prefix;
	}

	@Pure
	public String getSinglelineCommentPrefix() {
		return this.slPrefix;
	}

	/** Change the line prefix for the singleline comments.
	 * @param prefix the new prefix.
	 */
	public void setSinglelineCommentPrefix(String prefix) {
		this.slPrefix = prefix;
	}

	@Inject
	public void setGrammarAccess(SARLGrammarAccess access) {
		if (this.mlStart == null || this.mlEnd == null) {
			AbstractRule mlRule = access.getML_COMMENTRule();
			for (AbstractElement element : ((Group) mlRule.getAlternatives()).getElements()) {
				if (element instanceof Keyword && this.mlStart == null) {
					this.mlStart = ((Keyword) element).getValue();
				} else if (element instanceof UntilToken && this.mlEnd == null) {
					this.mlEnd = ((Keyword) ((UntilToken) element).getTerminal()).getValue();
				}
			}
		}
		if (this.mlLinePrefix == null) {
			this.mlLinePrefix = this.mlStart.substring(this.mlStart.length() - 1);
		}
		if (this.slPrefix == null) {
			AbstractRule slRule = access.getSL_COMMENTRule();
			for (AbstractElement element : ((Group) slRule.getAlternatives()).getElements()) {
				if (element instanceof Keyword) {
					this.slPrefix = ((Keyword) element).getValue().trim();
					break;
				}
			}
		}
	}

	@Pure
	public String format(String doc) {
		return format(doc, (String) null);
	}

	@Pure
	public String format(String doc, String indentation) {
		IAppendable appendable = new StringBuilderBasedAppendable();
		format(doc, indentation, appendable);
		return appendable.getContent();
	}

	@Pure
	public void format(String doc, IAppendable appendable) {
		format(doc, null, appendable);
	}

	@Pure
	public void format(String doc, String indentation, IAppendable appendable) {
		if (!Strings.isEmpty(doc)) {
			String indent = Strings.emptyIfNull(indentation);
			String prefix = getLinePrefix(getMultilineCommentLinePrefix(), true, false);
			final String linePrefix = getLinePrefix(getMultilineCommentLinePrefix(), false, false);
			final String linePostfix = getLinePostfix(Strings.newLine());
			boolean first = true;
			for (String line : Strings.split(doc, Strings.newLine())) {
				if (first) {
					first = false;
				} else {
					appendable.append(indent);
				}
				formatLine(appendable, line.trim(), prefix, linePostfix);
				prefix = linePrefix;
			}
		}
	}

	/** Replies the string that should appear at the start of each documentation line.
	 *
	 * @param prefix the default prefix text.
	 * @param isFirstLine indicates if the prefix string is for the first line of the documentation,
	 *    or the other lines.
	 * @param isLastLine indicates if the prefix string is for the last line of the documentation,
	 *    or the other lines.
	 * @return the real prefix text.
	 */
	@Pure
	protected String getLinePrefix(String prefix, boolean isFirstLine, boolean isLastLine) {
		if (isFirstLine) {
			return " ";
		} else if (isLastLine) {
			return " " + prefix;
		}
		return " " + prefix + " ";
	}

	/** Replies the string that should appear at the end of each documentation line.
	 *
	 * @param postfix the default postfix text.
	 * @return the real postfix text.
	 */
	@Pure
	protected String getLinePostfix(String postfix) {
		return postfix;
	}

	/** Format a line of comment.
	 *
	 * @param appendable the result of the format.
	 * @param line the line to format.
	 * @param prefix the expected prefix text for the line.
	 * @param postfix the expected postfix text for the line.
	 */
	@Pure
	protected void formatLine(IAppendable appendable, String line, String prefix, String postfix) {
		String simpleLine = (line == null) ? "" : line.trim();
		String simplePrefix = (prefix == null) ? "" : prefix.trim();
		String simplePostfix = (postfix == null) ? "" : postfix.trim();
		if (prefix != null) {
			appendable.append(prefix);
		}
		if (!Strings.isEmpty(simplePrefix) && simpleLine.startsWith(simplePrefix)) {
			int index = simplePrefix.length();
			while (index < simpleLine.length() && Character.isSpaceChar(simpleLine.charAt(index))) {
				++index;
			}
			simpleLine = simpleLine.substring(index);
		}
		if (!Strings.isEmpty(simplePostfix) && simpleLine.endsWith(simplePostfix)) {
			int index = simpleLine.length() - simplePostfix.length() - 1;
			while (index < simpleLine.length() && Character.isSpaceChar(simpleLine.charAt(index))) {
				--index;
			}
			simpleLine = simpleLine.substring(0, index + 1);
		}
		appendable.append(simpleLine);
		if (postfix != null) {
			appendable.append(postfix);
		}
	}

	@Pure
	public void formatMultilineComment(ITextReplacerContext context, IComment comment) {
		final ITextRegionAccess access = comment.getTextRegionAccess();
		final String indentationString = context.getIndentationString();
		final String postfix = getLinePostfix(null);
		final String fullText = comment.getText();
		final String startSymbols = getMultilineCommentStartSymbols();
		int startOffset = fullText.indexOf(startSymbols);
		if (startOffset < 0) {
			startOffset = 0;
		} else {
			startOffset += startSymbols.length();
		}
		final String endSymbols = getMultilineCommentEndSymbols();
		int endOffset = fullText.indexOf(endSymbols, startOffset);
		if (endOffset < 0) {
			endOffset = fullText.length();
		}
		final String startLineSymbols = getMultilineCommentLinePrefix();
		final int commentOffset = comment.getOffset();
		ILineRegion currentLine = access.regionForLineAtOffset(startOffset + commentOffset);
		boolean firstLine = true;
		while (currentLine != null) {
			int textStartOffset;
			int lineOffset = currentLine.getOffset();
			String referenceText = fullText.substring(
					Math.max(lineOffset - commentOffset, startOffset),
					Math.min(currentLine.getEndOffset() - commentOffset, endOffset));
			// Move to next line
			currentLine = currentLine.getNextLine();
			if (!Strings.isEmpty(referenceText) || currentLine != null) {
				String prefix;
				if (firstLine) {
					firstLine = false;
					textStartOffset = 0;
					// Skip prefix symbols (for Javadoc-like comments).
					while ((textStartOffset < referenceText.length())
							&& referenceText.regionMatches(textStartOffset, startLineSymbols, 0, startLineSymbols.length())) {
						textStartOffset += startLineSymbols.length();
					}
					referenceText = referenceText.substring(textStartOffset);
					prefix = getLinePrefix(null, true, false);
					textStartOffset += Math.max(lineOffset - commentOffset, startOffset);
				} else {
					textStartOffset = Math.max(lineOffset - commentOffset, startOffset);
					prefix = indentationString + getLinePrefix(startLineSymbols, false, false);
				}
				// Format the line
				StringBuilderBasedAppendable appendable = new StringBuilderBasedAppendable();
				formatLine(appendable, referenceText, prefix, postfix);
				String newText = appendable.getContent();
				// Change the text
				if (!Strings.equal(referenceText, newText)) {
					ITextSegment target = access.regionForOffset(textStartOffset + commentOffset, referenceText.length());
					context.addReplacement(target.replaceWith(newText));
				}
			}
		}
		// Format the closing symbols.
		final String newLineString = context.getNewLinesString(1);
		int textEndOffset = endOffset - 1;
		while (textEndOffset > startOffset
				&& isSpaceChar(fullText.charAt(textEndOffset))) {
			--textEndOffset;
		}
		String referenceText;
		StringBuilderBasedAppendable appendable = new StringBuilderBasedAppendable();
		if (textEndOffset <= startOffset || !Character.isWhitespace(fullText.charAt(textEndOffset))) {
			// Do not find a new line.
			appendable.append(newLineString);
			textEndOffset = endOffset;
			referenceText = endSymbols;
		} else {
			++textEndOffset;
			referenceText = fullText.substring(textEndOffset, endOffset) + endSymbols;
		}
		String prefix = indentationString + getLinePrefix(endSymbols, false, true);
		formatLine(appendable, "", prefix, null);
		String newText = appendable.getContent();
		if (!Strings.equal(referenceText, newText)) {
			ITextSegment target = access.regionForOffset(textEndOffset + commentOffset, referenceText.length());
			context.addReplacement(target.replaceWith(newText));
		}
	}

	/** Replies if the given character is a Unicode space.
	 * <p>This function does not match the new-line and other whitespace characters.
	 */
	protected static boolean isSpaceChar(char character) {
		return (((1 << Character.SPACE_SEPARATOR) >> Character.getType((int) character)) & 1) != 0;
	}

	@Pure
	public void formatSinglelineComment(ITextReplacerContext context, IComment comment) {
		String text = comment.getText();
		String prefix = getSinglelineCommentPrefix();
		ITextRegionAccess access = comment.getTextRegionAccess();
		int commentOffset = comment.getOffset();
		int symbolOffset = text.indexOf(prefix);
		int textZoneOffset;
		if (symbolOffset >= 0) {
			textZoneOffset = symbolOffset + prefix.length();
		} else {
			textZoneOffset = 0;
		}
		int textOffset = textZoneOffset;
		while (textOffset < text.length() && isSpaceChar(text.charAt(textOffset))) {
			++textOffset;
		}
		boolean isEndOfLine = (textOffset < text.length()) && Character.isWhitespace(text.charAt(textOffset));
		if (isEndOfLine) {
			// No text in the comment.
			if (textOffset != textZoneOffset) {
				// Remove trailing spaces
				ITextSegment prefixRegion = access.regionForOffset(
						commentOffset + textZoneOffset, textOffset - textZoneOffset);
				String t0 = access.textForOffset(0, commentOffset + textZoneOffset);
				String t1 = access.textForOffset(commentOffset + textZoneOffset, textOffset - textZoneOffset);
				context.addReplacement(prefixRegion.replaceWith(""));
			}
		} else if ((textZoneOffset + 1) != textOffset) {
			// Text in the comment AND invalid number of spaces.
			ITextSegment prefixRegion = access.regionForOffset(
					commentOffset + textZoneOffset, textOffset - textZoneOffset);
			String t0 = access.textForOffset(0, commentOffset + textZoneOffset);
			String t1 = access.textForOffset(commentOffset + textZoneOffset, textOffset - textZoneOffset);
			context.addReplacement(prefixRegion.replaceWith(" "));
		}
	}

}

